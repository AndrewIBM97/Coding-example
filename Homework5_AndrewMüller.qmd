---
title: "Homework 5: Raking, Post-Stratification, and MrP"
subtitle: "Preparation for the Research Seminar Political Data Journalism<br>Fall Semester 2025<br>Department of Political Science<br>University of Zurich"
author:
  - name: Andrew Ian Müller
    affiliation: 20-700-761
date: today
date-format: "D MMMM YYYY"
author-title: Name
affiliation-title: Matrikelnummer
published-title: Date
lightbox: true
# bibliography: references.bib
format:
  html:
    code-fold: true
    code-tools: true
    self-contained: true
    toc: true
    toc-depth: 2
    fig-width: 12
    fig-height: 8
    fig-align: center
    cap-location: top
    code-link: true
    include-in-header:
      text: "<link href='https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;700&display=swap rel='stylesheet''> <style> body {font-family: 'Source Sans Pro', sans-serif; text-align: justify} </style>"
---

```{r}
#| include: false
notebook_starttime <- Sys.time()
```

## Instructions

For this assignment, you need to complete the exercises and submit your solutions in the form of **rendered `.html` documents**. **Full points** will be given only for complete written answers, well-designed figures, and properly formatted tables, not for single snippets of code or printed output from R functions. You need to use informative titles, captions, and labels for every table and figure. You need to use `set.seed(1234)` whenever you need to set a seed to make your analysis reproducible. **Make sure to fully interpret all of the results in written answers!**

Complete the following steps:

1.  Open RStudio by double-clicking the Rproject (`.Rproj`) file, then open the Quarto markdown (`.qmd`) file of the exercise in RStudio

2.  Replace FIRSTNAME LASTNAME in the YAML header of this document with your own name and `1234567890` with your own Matrikelnummer.

3.  For each question, replace `# YOUR CODE` with your own R code, and replace `YOUR ANSWER` with your written answers (note: some questions only require a written answer). **You can add additional R chunks, table and figure captions, citations, footnotes, and cross-references, as needed.**

4.  Render the Quarto markdown (`.qmd`) file to a `.html` file by clicking the "Render" button. This will run the entire script from top to bottom in a fresh R session. Make sure that there are no errors in your code. Carefully reading any error messages will help you debugging your code. It is strongly recommend to render the document regularly while working on completing the assignment, in order to ensure that the code works as intended, and that you do not encounter any last minute surprises. **I will only grade fully rendered `.html` files!**

5.  **When you are finished with all exercises**, compress all the files in your assignment folder to a `.zip` file (the Quarto markdown files, the HTML files you created, the Data folder, the Rproject.Rproj file, and the Declaration of Authorship).

6.  **Submit** the zipped folder before the deadline in the drop box of the course on OLAT.

## Load Packages {.unlisted}

```{r}
#| message: false

# Load your packages here
library("autoMrP")
library("conflicted")
library("fansi")
library("foreign")
library("haven")
library("modelsummary")
library("survey")
library("swissMrP") # Install from GitHub with pak::pkg_install("lleemann/swissMrP")
library("tidyverse")
library("knitr")
library("lme4")
conflicts_prefer(
  dplyr::filter
)
```

```{r}
#| code-fold: true
#| code-summary: Set ggplot theme and use colorblind-friendly color palette

# Set ggplot theme
theme_set(
  theme_minimal() +
    theme(
      plot.title = element_text(face = "bold"),
      plot.title.position = "plot",
      legend.position = "top",
      panel.grid.minor = element_blank()
    )
)

# Use colorblind-friendly color palette
okabe_ito <- unname(palette.colors(palette = "Okabe-Ito")[c(2:8, 1, 9)])
options(ggplot2.continuous.color = okabe_ito)
options(ggplot2.continuous.colour = okabe_ito)
options(ggplot2.continuous.fill = okabe_ito)
options(ggplot2.discrete.color = okabe_ito)
options(ggplot2.discrete.colour = okabe_ito)
options(ggplot2.discrete.fill = okabe_ito)

# Turn off scientific notation
options(scipen = 999)
```

# Question 1

### In this question, take a closer look at the vote on the initiative to strengthen the postal service (Volksinitiative Postdienst für alle (5120)).

## Question 1a

### Find the offcial result and compare it with the mean value in the VOX data set – what do you see?

```{r}
#| code-fold: true
vox <- read_dta("Data/vox_data.dta")


vox_5120 <- vox |> 
  filter(AbstNrBFS == 5120)

# Official results: Abgelehnt (49.77% Ja-Stimmen und 9.5 von 23 Standesstimmen)
vox_5120_mean <- mean(vox_5120$abst_entscheid, na.rm = T)
t.test(vox_5120$abst_entscheid, 
       alternative = "two.sided",
       mu = 0.4977)
cat("Mean yes vote in VOX data:", round(vox_5120_mean * 100, 2), "%\n")
```

The official result of the "Volksinitiative Postdienst für alle" shows that 49.77% of voters cast a yes vote and 50.23% cast a no vote. The mean from the vox data, however, lies at 58.23% yes votes. A t-test shows that the difference is statistically significant on a p < 0.001 level. 

## Question 1b

### Use raking by age, sex, and education and compare your result with the offcial result and the answer from Question 1a. Does raking help?

```{r}
#| code-fold: true

# get rid of missings and recode variables if necessary
table(vox_5120$age_group, useNA = "always") # 0 NA
table(vox_5120$sexe, useNA = "always") # 0 NA and coded differently than census!
table(vox_5120$educ, useNA = "always") # 6 NA

drop_edu <- which(is.na(vox_5120$educ))
vox_5120 <- vox_5120[-drop_edu, ]
table(vox_5120$educ, useNA = "always") # 0 NA now

# recode variable sexe for raking
vox_5120$female <- (vox_5120$sexe - 1)  
table(vox_5120$female)

# get census 
census <- swissMrP::census$census48.MAZH2013
educ_national <- rep(NA, 6)
educ_national[1] <- sum(census[1:8, ]) / sum(census)
educ_national[2] <- sum(census[9:16, ]) / sum(census)
educ_national[3] <- sum(census[17:24, ]) / sum(census)
educ_national[4] <- sum(census[25:32, ]) / sum(census)
educ_national[5] <- sum(census[33:40, ]) / sum(census)
educ_national[6] <- sum(census[41:48, ]) / sum(census)

female_national <- rep(NA, 2)
even <- seq(2, 48, by = 2)
odd <- even - 1
female_national[1] <- sum(census[odd, ]) / sum(census)
female_national[2] <- sum(census[even, ]) / sum(census)

age_national <- rep(NA, 4)
a_pointer <- rep(c(1, 1, 2, 2, 3, 3, 4, 4), 6)
age_national[1] <- sum(census[which(a_pointer == 1), ]) / sum(census)
age_national[2] <- sum(census[which(a_pointer == 2), ]) / sum(census)
age_national[3] <- sum(census[which(a_pointer == 3), ]) / sum(census)
age_national[4] <- sum(census[which(a_pointer == 4), ]) / sum(census)




# define distributions
age_dist <- data.frame(age_group = c(1:4), Freq = length(vox_5120$AbstNrBFS) * age_national)
female_dist <- data.frame(female = c(0, 1), Freq = length(vox_5120$AbstNrBFS) * female_national)
educ_dist <- data.frame(educ = c(1:6), Freq = length(vox_5120$AbstNrBFS) * educ_national)

vox5120_unweighted <- svydesign(ids = ~1, data = vox_5120)


vox5120_weighted <- rake(
  design = vox5120_unweighted,
  sample.margins = list(~female, ~educ, ~age_group),
  population.margins = list(female_dist, educ_dist, age_dist)
)

# look at weights
summary(weights(vox5120_weighted))

# trim weights
vox5120_weighted_trimmed <- trimWeights(vox5120_weighted,
  upper = 5,
  strict = TRUE
)
```

```{r}
#| code-fold: true
#| label: tbl-rake_results
#| tbl-cap: "Raking results for vote 5120"
tab1 <- svytable(~abst_entscheid, design = vox5120_weighted_trimmed)
prop <- 100 * tab1 / sum(tab1)

table_rake <- data.frame(
  Vote = c("No (0)", "Yes (1)"),
  Percentage = as.numeric(prop)
)
table_rake$Percentage <- round(table_rake$Percentage, 2)
knitr::kable(table_rake)
```

Seen in @tbl-rake_results, the share of yes votes after raking is 57.97%, which is still significantly higher than the true value of 49.77%. Therefore, raking for age, education and sex does not help to get closer to the true value. One potential reason is that raking does not adjust for biases arising from interactions, such as age group x gender effects on voting. 

## Question 1c

### Use post-stratifcation by age, sex, and education and compare your result with the offcial result and answer from Question 1a. Does post-stratifcation help?

```{r}
#| code-fold: true
dim(census)
types_population <- rowSums(census)
types_population <- types_population / sum(types_population) # get proportion

idealtype <- rep(NA, dim(vox_5120)[1])

e_pointer <- kronecker(c(1,2,3,4,5,6), rep(1,8)) 
f_pointer <- rep(c(0, 1), 24)



for (i in 1:48) {
  E  <- which(vox_5120$educ      == e_pointer[i])
  A  <- which(vox_5120$age_group == a_pointer[i])
  Fe <- which(vox_5120$female    == f_pointer[i])
  rows <- intersect(intersect(A, E), Fe)
  idealtype[rows] <- i
}

tab <- table(factor(idealtype, levels = 1:48))
tab
which(tab == 0) # no idealtype at 40

# Force all 48 ideal types to appear in the frequency vector
tab <- table(factor(idealtype, levels = 1:48))
idealtype_sample_freq <- tab / sum(tab)



weights_ps <- types_population / idealtype_sample_freq # generate post-stratification weights

# get mean estimate for each stratum
post_mean <- rep(0, 48)

for (i in 1:48) {
  post_mean[i] <- mean(vox_5120$abst_entscheid[idealtype == i], na.rm = TRUE)
}

result_post <- sum(post_mean * weights_ps, na.rm = TRUE) / sum(weights_ps[-which(is.na(post_mean))])
cat("Post-stratified mean yes vote:", round(result_post * 100, 3), "%\n")





```

Using post stratification we get a share of 57.11% yes votes, which is still significantly higher than the true value of 49.77%. Therefore, post-stratification for age, education and sex does not help to get closer to the true value. One potential limitation of post stratification that could cause problems is that it requires the full joint distribution of all stratifying variables and assumes that each ideal type is internally homogeneous. 

## Question 1d

### Use MrP by age, sex, education, and canton. You can use an empty model and use a package or write your own code. Compare your result with the offcial result and the answer from Question 1a. Does MrP help?

```{r}
#| code-fold: true
vox5120_clean <- na.omit(vox_5120) |> 
  mutate(age = age_group, 
         education = educ,
         woman = female) # change variable name to fit swissMrP


vox_mrp1 <- glmer(
  abst_entscheid ~ 1 +
    (1 | woman) +
    (1 | education) +
    (1 | age) +
    (1 | cantonnr) + 
    (1 | region), # the swissMrP package needs region
  family = binomial(link = "probit"),
  data   = vox5120_clean
)


length(table(vox5120_clean$cantonnr))


# add information for missing units
q <- swissMrP(
  response.model = vox_mrp1, 
  uncertainty = FALSE
)
summary(q)
q
result_mrp1 <- sum(q * colSums(census)) / sum(colSums(census))
cat("MrP mean yes vote:", round(result_mrp1 * 100, 2), "%\n")
```

Comparing the result of 58.06% to the official result of 49.77% yes votes, as well as well as the mean from the vox data set showing a yes share of 58.23%, we see that MrP does not help to get closer to the real value either. A limitation of MrP is that if important predictors of voting behavior are missing, the model cannot correct sample bias. In the context of the Volksinitiative Postdienst für alle (5120) ,the model will not improve the result if age, gender and education are only weakly correlated with voting yes.

## Question 1e

### Estimate a MrP model that has only random effects for canton, education, and age group but not for gender. You will have to write your own code. How do the results change? Can you explain it?

```{r}
#| code-fold: true

vox_mrp2 <- glmer(
  abst_entscheid ~ 1 +
    (1 | education) +
    (1 | age) +
    (1 | cantonnr),
  family = binomial(link = "probit"),
  data   = vox5120_clean
)

## extract random effects (intercepts only)
re_agegroup <- ranef(vox_mrp2)$age[[1]]          # or ranef(vox_mrp2)$age[,"(Intercept)"]
re_educ     <- ranef(vox_mrp2)$education[[1]]    # <- make sure this matches the model
re_cantonnr <- ranef(vox_mrp2)$cantonnr[[1]]

## combine age and education random effects
age_re  <- rep(kronecker(re_agegroup, c(1, 1)), 6)   # check lengths vs your design
educ_re <- kronecker(re_educ, rep(1, 8))

ind_re <- rowSums(cbind(age_re, educ_re))
ind_re <- ind_re + fixef(vox_mrp2)[["(Intercept)"]]

## linear predictor per canton
y_hat <- rep(NA_real_, 1248)   # 26 * 48
for (i in 1:26) {
  a <- ((i - 1) * 48) + 1
  b <- a + 47
  y_hat[a:b] <- ind_re + re_cantonnr[i]   # <- fixed name
}

## predicted probabilities
pred_p <- pnorm(y_hat)

## population weights
it_pop <- c()
for (i in 1:26) {
  it_pop <- c(it_pop, census[, i])
}

## estimate result prediction
result <- sum(pred_p * it_pop, na.rm = TRUE) / sum(it_pop, na.rm = TRUE)
cat("MrP mean yes vote without gender:", round(result * 100, 2), "%\n")

```

The results of the MrP model without gender are marginally worse (0.37 percentage points) than with gender as random effect. The share of yes votes lies at 58.43%, which is still far from the official result of 49.77%. One indication, is that gender does not help to predict the outcome, in that there are no significant differences in voting between men and women in the context of this vote. Furthermore, the MrP model is overall rather weak and far away from the official result, so getting rid of a weak predictor won't change the overall result significantly. A reason for this could be that other variables that are not included in the model play a bigger role or that the inclusion of level 2 variables would improve the model.

# Question 2

### In this question you will work with the ballot vote you have chosen in the Lab.

## Question 2a

### Inform yourself about the vote and summarize it briefly; the content, the starting position, the main actors, and the result of the vote. Which variables could be relevant at Level 2 and why?

```{r}
#| code-fold: true
# 4910	Volksinitiative gegen Asylrechtsmissbrauch FL
# https://abstimmungen.admin.ch/details/2002-11-24?proposalId=4910
```

The ["Volksinitiative gegen Asylrechtsmissbrauch"](https://www.parlament.ch/de/ratsbetrieb/suche-curia-vista/geschaeft?AffairId=20010036) was a popular initiative in Switzerland held in 2002 that sought to tighten Switzerland's asylum system. This was planned to be done by speeding up procedures, restricting benefits, limiting medical care and work rights for certain asylum seekers, and reducing Switzerland’s overall attractiveness as an asylum destination. The initiative had begun amidst growing public concern about Switzerland's asylum policy. Concerning the main actors, the Swiss People's Party (SVP) pushed for stricter rules while the Federal Council and a parliamentary majority opposed the initiative, arguing that existing reforms already addressed many issues and that the proposed measures went too far. [The result](https://abstimmungen.admin.ch/details/2002-11-24?proposalId=4910) was that the vote was turned down in 2002 with 50.09% of the voters casting a no and 49.91% casting a yes. The share of yes and no votes strongly followed an East-West divide, with Eastern cantons voting in favor of the vote and Western cantons, including Ticino being against the vote. Relevant level 2 variables therefore could be share of 
German speakers, since German speaking cantons tend to vote more conservatively. However some German speaking cantons such as Lucerne, Bern, Zug and Basel voted no. Thus, another important level 2 variable could be the share of SVP voters within a canton, since these will likely be in favor of a bill.  
## Question 2b

### In the VOX dataset you have 4 level 2 variables. Calculate an empty MrP model (no level 2 predictors) and then estimate a model with the – in your opinion – best level 2 variables (you can also add new level 2 variables).

```{r}
#| code-fold: true

vox_4910 <- vox |>
  dplyr::filter(AbstNrBFS == 4910) |>
  dplyr::mutate(
    education = educ,
    woman     = (sexe - 1),
    age       = age_group
  ) |>
  dplyr::select(
    abst_entscheid,
    woman,
    education,
    age,
    cantonnr,
    region,
    german_share,
    romkath_share,
    leftvote_share,
    svpvote_share
  ) |>
  na.omit()

missing_cantons <- setdiff(1:26, sort(unique(vox_4910$cantonnr)))
missing_cantons  # should be 6

table(vox_4910$abst_entscheid)

L2_full <- vox_4910 |>
  dplyr::group_by(cantonnr) |>
  dplyr::summarise(
    svpvote_share  = unique(svpvote_share[!is.na(svpvote_share)])[1],
    german_share = unique(german_share[!is.na(german_share)])[1],
    region         = unique(region[!is.na(region)])[1],
    .groups = "drop"
  )

augment_data_4910 <- L2_full |>
  summarise(
    svpvote_share  = mean(svpvote_share,  na.rm = TRUE),
    german_share = mean(german_share, na.rm = TRUE),
    region         = round(median(region, na.rm = TRUE)) 
  ) |>
  as.matrix()

augment.row <- 1




# 3) Fit empty and L2 models
mrp_empty <- glmer(
  abst_entscheid ~ 1 +
    (1 | woman) +
    (1 | education) +
    (1 | age) +
    (1 | cantonnr) +
    (1 | region),
  data = vox_4910,
  family = binomial(link = "probit")
)

mrp_level2 <- glmer(
  abst_entscheid ~
    svpvote_share + german_share +
    (1 | woman) +
    (1 | education) +
    (1 | age) +
    (1 | cantonnr) +
    (1 | region),
  data = vox_4910,
  family = binomial(link = "probit")
)


```

## Question 2c

### Compare the models and show which approach leads to the best results.
```{r}
#| code-fold: true
census_4910 <- swissMrP::census$census48.MAZH2013
canton_pop  <- colSums(census_4910)



pred_empty_4910 <- swissMrP(
  response.model = mrp_empty,
  uncertainty    = FALSE
)
p_empty_vec <- as.numeric(pred_empty_4910)
nat_empty   <- sum(p_empty_vec * canton_pop) / sum(canton_pop)


pred_L2_4910 <- swissMrP(
  response.model = mrp_level2,
  uncertainty    = FALSE,
  augment.data   = augment_data_4910,
  augment.row    = 6
)
p_L2_vec <- as.numeric(pred_L2_4910)
nat_L2    <- sum(p_L2_vec * canton_pop) / sum(canton_pop)



official_nat <- 0.4991   # 49.91% yes

round(
  c(
    "Empty MrP"            = nat_empty,
    "MrP + Level-2 inputs" = nat_L2,
    "Official result"      = official_nat
  ) * 100,
  2
)

```

Adding level 2 variables does not increase the accuracy of predicting the share of yes votes significantly as opposed to the empty model. The model with level two variables is 0.41 percentage points closer to the official yes votes share of 49.91%. Furthermore, both the empty MrP with 44.58% yes vote share and the MrP with level 2 variables with a yes vote share of 44.99% still deviate from the official result yes votes. This can be the case when the data set has small number of observations per canton, the predictors don't accurately capture the voting behavior or if there is a lack of variation between the groups. 

## Question 2d

### Use automrp to see if machine learning can help you here (without GB and SVM).

```{r}
#| code-fold: true
swissMrP::census$census48.MAZH2013

# 2 * 4 * 6 * 26 = 1248 rows (ideal types across cantons)
data_census <- data.frame(matrix(NA, 2 * 4 * 6 * 26, 7))


data_census[, 1] <- kronecker(1:26, rep(1, 48))
colnames(data_census)[1] <- "cantonnr"

data_census[, 2] <- rep(kronecker(1:6, rep(1, 8)), 26)
colnames(data_census)[2] <- "educ"


data_census[, 3] <- rep(rep(kronecker(1:4, c(1, 1)), 6), 26)
colnames(data_census)[3] <- "agegroup"


data_census[, 4] <- rep(rep(0:1, 24), 26)
colnames(data_census)[4] <- "woman"

colnames(data_census)[5] <- "german"
data_census[, 5] <- 0
german_canton <- which(table(vox$german_share, vox$cantonnr)[2, ] != 0)
for (i in 1:26) {
  if (i %in% german_canton) {
    data_census[data_census$cantonnr == i, 5] <- 1
  }
}

# proportion within canton (post-stratification weights)
colnames(data_census)[6] <- "proportion"
for (i in 1:26) {
  numbers_census <- swissMrP::census$census48.MAZH2013[, i]
  numbers_census <- numbers_census / sum(numbers_census)
  a <- 1 + (i - 1) * 48
  b <- i * 48
  data_census[a:b, 6] <- numbers_census
}

colnames(data_census)[7] <- "region"


region_by_canton <- vox |>
  dplyr::filter(!is.na(region)) |>
  dplyr::group_by(cantonnr) |>
  dplyr::summarise(
    region = unique(region)[1],
    .groups = "drop"
  )

data_census$region <- NA_integer_
for (i in 1:26) {
  r_i <- region_by_canton$region[region_by_canton$cantonnr == i]
  if (length(r_i) >= 1) {
    data_census$region[data_census$cantonnr == i] <- r_i[1]
  }
}


data_run <- vox_4910

data_analysis_4910 <- data.frame(
  yes_4910       = data_run$abst_entscheid,
  cantonnr       = data_run$cantonnr,
  region         = data_run$region,
  woman          = data_run$woman,
  educ           = data_run$education,
  agegroup       = data_run$age,
  german_share   = data_run$german_share,
  romkath_share  = data_run$romkath_share,
  leftvote_share = data_run$leftvote_share,
  svpvote_share  = data_run$svpvote_share
)

head(data_analysis_4910)


data_census$german_share <- NA
for (i in 1:26) {
  xxxx <- unique(data_analysis_4910$german_share[data_analysis_4910$cantonnr == i])
  if (length(xxxx) > 0) data_census$german_share[data_census$cantonnr == i] <- xxxx[1]
}

data_census$romkath_share <- NA
for (i in 1:26) {
  xxxx <- unique(data_analysis_4910$romkath_share[data_analysis_4910$cantonnr == i])
  if (length(xxxx) > 0) data_census$romkath_share[data_census$cantonnr == i] <- xxxx[1]
}

data_census$leftvote_share <- NA
for (i in 1:26) {
  xxxx <- unique(data_analysis_4910$leftvote_share[data_analysis_4910$cantonnr == i])
  if (length(xxxx) > 0) data_census$leftvote_share[data_census$cantonnr == i] <- xxxx[1]
}

data_census$svpvote_share <- NA
for (i in 1:26) {
  xxxx <- unique(data_analysis_4910$svpvote_share[data_analysis_4910$cantonnr == i])
  if (length(xxxx) > 0) data_census$svpvote_share[data_census$cantonnr == i] <- xxxx[1]
}

head(data_census)

```

```{r}

mrp_4910_ml <- auto_MrP(
  y           = "yes_4910",
  L1.x        = c("woman", "educ", "agegroup"),
  L2.x        = c("german_share", "leftvote_share", "romkath_share"),
  L2.unit     = "cantonnr",
  cores       = parallelly::availableCores(),
  survey      = data_analysis_4910,
  census      = data_census,
  bin.proportion = "proportion",
  best.subset = TRUE,
  lasso       = TRUE,
  pca         = TRUE,
  gb          = FALSE,
  svm         = FALSE,
  mrp         = TRUE,
  verbose     = TRUE
)

# canton-level MrP estimates from autoMrP (machine-learning-enhanced model)
mrp_4910_ml_est <- c(mrp_4910_ml$classifiers$mrp)
mrp_4910_ml_est




# https://swissvotes.ch/vote/491.00
# insert yes vote shares by canton
official_result_491 <- c(
  50.6, 48.6, 48.1, 53.2, 61.6, 51.1, 54.0, 63.0, 48.9, 44.3, 55.6, 43.0,
  50.3, 51.6, 55.9, 60.3, 60.9, 51.5, 58.0, 60.9, 48.1, 41.7, 42.3, 42.6, 38.6,
  39.7
) / 100



```

```{r}
#| code-fold: true
#| label: tbl-automrp_results
#| tbl-cap: "autoMrP results for vote 4910"
auto_pred_full <- rep(NA_real_, 26)
auto_pred <- as.numeric(mrp_4910_ml$classifiers$mrp)

# 2) Cantons present in survey
present_cantons <- sort(unique(data_analysis_4910$cantonnr))

# 3) Fill known predictions
auto_pred_full[present_cantons] <- auto_pred

# 4) Missing canton(s)
missing_cantons <- setdiff(1:26, present_cantons)

# Build region lookup
region_full <- data_census |>
  dplyr::group_by(cantonnr) |>
  dplyr::summarise(
    region = unique(region)[!is.na(unique(region))][1],
    .groups = "drop"
  )

# 5) Impute missing canton by region mean
for (mc in missing_cantons) {
  mc_region <- region_full$region[region_full$cantonnr == mc]
  similar_cantons <- region_full$cantonnr[
    region_full$region == mc_region &
    region_full$cantonnr %in% present_cantons
  ]
  auto_pred_full[mc] <- mean(auto_pred_full[similar_cantons], na.rm = TRUE)
}

# 6) National estimate
auto_mrp_nat <- sum(auto_pred_full * canton_pop) / sum(canton_pop)
cat("autoMrP national yes-share:", round(auto_mrp_nat * 100, 2), "%\n")

# 7) Comparison table
mrp_ml_compare <- data.frame(
  canton   = 1:26,
  autoMrP  = round(auto_pred_full * 100, 1),
  official = round(official_result_491 * 100, 1)
)

knitr::kable(
  mrp_ml_compare,
  caption = "Canton-level yes-shares: autoMrP vs official result"
)


```

```{r}
#| code-fold: true
#| label: fig-mrp_ml_cantons
#| fig-cap: "Comparison of MRP with L2 and autoMrP (ML), canton-level"
# 1) Use the 26-canton autoMrP vector we already constructed
auto_mrp_canton <- auto_pred_full          # length 26

# 2) Canton-level MRP+L2 predictions from swissMrP
mrp_L2_df <- data.frame(
  canton        = 1:26,
  mrp_estimates = as.numeric(pred_L2_4910)  # length 26
)

# 3) Base df with all 26 cantons, autoMrP and true values
df_plot <- data.frame(
  canton      = 1:26,
  automrp_est = auto_mrp_canton,          # length 26
  true_values = official_result_491       # length 26
) |>
  dplyr::left_join(mrp_L2_df, by = "canton")

# ----------------- PLOT -----------------
df_plot |>
  ggplot() +
  # autoMrP (blue)
  aes(x = automrp_est, y = true_values) +
  geom_point(color = "blue", shape = 19) +
  # MRP with L2 (red)
  geom_point(aes(x = mrp_estimates, y = true_values),
             color = "red", shape = 19) +
  geom_abline(intercept = 0, slope = 1) +
  coord_equal() +
  labs(
    x = "Model estimates (blue = autoMrP, red = MRP with L2)",
    y = "Official yes-share"
  )

# ----------------- MSEs -----------------
# autoMrP: all cantons
mse_automrp <- mean( (df_plot$automrp_est - df_plot$true_values)^2 )

# MRP with L2: all cantons (we have full coverage via augment.data)
mse_mrp_L2 <- mean( (df_plot$mrp_estimates - df_plot$true_values)^2 )

mse_automrp
mse_mrp_L2



```

Using a machine learning approach with the autoMrP the results shown in @tbl-automrp_results still indicate large deviance from the official results of yes shares. Illustrated in @fig-mrp_ml_cantons we can see that both the MrP model with level 2 variables, as well as the autoMrP model deviate strongly from the official results of the ["Volksinitiative gegen Asylrechtsmissbrauch"](https://www.parlament.ch/de/ratsbetrieb/suche-curia-vista/geschaeft?AffairId=20010036). One potential issue why also autoMrP does not help, is that many cantons have small number of observations and the canton of Obwalden is missing, since it only contains NAs as votes. Furthermore, autoMrP will not improve the results when the level 2 predictors can distinguish meaningfully between cantons. 

::: {.callout-note collapse="true"}
## Session Information

This analysis was produced using the following environment.

```{r}
sessioninfo::session_info()
quarto::quarto_version()
```
:::

::: callout-warning
## Notebook Runtime

```{r}
#| echo: false
notebook_endtime <- Sys.time()
notebook_runtime <- difftime(notebook_endtime, notebook_starttime, units = "mins")
gt::html("The whole notebook took", round(notebook_runtime, 1), "minutes to run")
```
:::
